day 8
3种代码块     开发中用得少,面试可能会问
1. 局部代码块(在方法中出现,被限定了生命周期,及早释放,提高内存利用率)
2. 构造代码块(每次在访问构造方法前都加载一次)
3. 静态代码块(随类加载,只加载一次)

**继承**(重点) class B extends A() {}   体现了一种"is a"的关系
继承的好处和坏处
1. 好处:提高复用性,维护性,让类与类之间产生了联系(是多态的前提)
2. 坏处:类的耦合性增强了,对开发不利(高内聚,低耦合 内聚:独立完成某件事的能力  耦合:类与类的关系)
继承中关系:重名的时候
1. 变量关系:就近原则,子类有的变量就优先用子类
2. 方法关系:也是就近原则,不过有个特别的名字叫方法重写
3. 可以用this.和super.来选择调用子类还是父类中的
4. 方法重写:字类中的方法与父类中方法同名时,就叫子类方法对父类的重写.
方法重写的注意事项:
- 子类不能对父类中的私有方法进行重写
- 子类重写父类方法时,访问权限不能更低,最好一致.
- 父类静态方法,子类也必须通过静态方法进行重写
- 最好声明都一样
- 子类虽然能继承父类,但是构造方法无法继承,还得自己写;
override和overload(重载和重写)
- 方法重载:在一个类中可以创建多个同名方法,但是参数列表不同,调用时通过检测传入参数来决定使用哪个方法
- 方法重写:子类中有特殊需要,创建了一个与父类中同名的方法,就叫做子类对父类中某个方法的重写
this和super
1. 子类中的所有构造方法 默认都会访问父类中的空参构造方法,当父类中无空参构造(但是有有参构造)时
用super() 用来调用父类中的构造方法
- 可以在子类构造方法中首行加入super(参数1,参数...)来调用父类的有参构造  子类空参+super(参数)-->父类有参构造 子类有参构造+super(参数)-->父类有参构造
用this()  用来调用本类中的构造方法
- 注意:super()和this()只能出现在构造方法的首行 且不能同时出现
2. 













final关键字
1. 被final修饰过的变量
- 基本类型: 只能被赋一次值
- 引用类型: 地址值不能被改变,但是引用类型变量的属性值可以通过setXXX方法改变
2. 被final修饰过的方法不能被重写
3. 被final修饰过的类不能被继承

使用final的时机
1. 显示初始化
2. 构造初始化


day 9      多态   抽象    接口


多态 就是父类引用指向子对象 Father f = new Son();
多态前提
- 要有继承
- 要有方法重写
- 要有父类引用指向子对象
多态中成员访问特点
1. 成员变量:编译看左边,运行看左边(用父类的)
2. 成员方法:编译看左边,运行看右边(也叫动态绑定)
3. 静态方法:编译看左边,运行看左边
4. 总结:只有非静态的方法编译看左边,运行看右边.

多态的好处和弊端
1. 好处
- 提高了维护性(继承的原因)
- 提高了代码的扩展性(多态的原因) 在这里我犯了一个语法错误:将public void method(Cat c) {}方法写在了main方法里,导致报错

向上转型和向下转型
Person P = new superMan();向上转型
SuperMan sm = (SuperMan)p;向下转型


多态一般都是怎么用?  一般是用在方法声明,被当做参数传递进去
method(Animal a) 只要是继承了父类的子类 都可以传递进来
method(new Cat());

抽象 就是不知道的 
主要使用方法
- 当你无法具体描述一个方法时,就把方法抽象化,然后让子类继承,子类再根据具体情况对该方法进行重写
abstract  本质上就是比普通类多了一个abstract 可以创建抽象的类或者方法

抽象的使用范围
1. 抽象类 abstract class
2. 抽象方法 public abstract void XXX() {}
3. 抽象类的子类
- 要么也是抽象类
- 要么对抽象类中的所有抽象方法进行重写

抽象类中成员的特点
1. 成员变量不能被抽象化
2. 方法可以被抽象化
3. 创建抽象方法主要是用来强制子类重写该方法的
4. 创建非抽象方法则是为了提高复用性

abstarct不能与哪些关键字共存?
1. static: 被abstract修饰的方法没有方法体 被static修饰的可以用类名.方法调用 调用该类方法没有意义
2. final:  被abstract修饰的方法强制子类重写 被finnal修饰的不让子类重写 他俩本质矛盾
3. private: 被abstract修饰的方法强制子类重写 被private修饰的不让子类访问 


接口    interface A {}  class B implement A {}
接口其实就是体现了一种扩展功能的实现
接口特点
1. 成员变量：在接口中定义的变量都是常量,默认是public static final
2. 构造方法：接口没有构造方法
3. 成员方法：接口中的方法只能是是抽象方法 默认public abstract
类与类，类与接口，接口与接口的关系
1. 类与类：继承关系，只能单继承，可以多层继承
2. 类与接口：实现关系，可以单实现也可以多实现 class A implement Interface1，Interface2 () {}
3. 接口与接口：继承关系，同 类与类

抽象类和接口的区别
A.成员区别
- 抽象类:就比普通类多了一个能定义抽象的功能
- 接口:成员变量只能是常量,没有构造方法,成员方法只能是抽象方法.


猫狗案例加入跳高功能分析及其实现
案例演示
- 动物类:姓名,年龄,吃饭,睡觉(应该声明吃饭,睡觉为抽象类,每种动物睡觉的姿势不一样)
- 猫和狗
- 动物培训接口:跳高


主要框架:先定义一个父类Animal,父类里私有了变量,给出了setXXX和getXXX方法,将吃饭和睡觉定义成了抽象类方法然子类去重写以具体实现

接着定义了一个接口Jumping,用来扩展跳高的功能

然后定义一个子类Cat,Cat继承了animal,同时重写了吃饭和睡觉的方法.

最后定义了一个jumpCat,jumpCat不但继承了cat同时还implements了接口Jumping

		


总结:多态其实就是父类引用指向子对象 变化的都是子类
使用到的例子及其作用
和超人谈大生意中途超人去救人的的故事 帮助理解多态中,方法实现的方式是动态绑定,成员变量和静态方法则是编译看左边,运行也看左边  同时还讲了向上转型和向下转型 
这里的上指的是父类,下则是子类